package com.fede.app.crypto.trading.dao.impl.db;

import com.fede.app.crypto.trading.dao.IAssetPairsDao;
import com.fede.app.crypto.trading.exception.TechnicalException;
import com.fede.app.crypto.trading.logger.ISimpleLog;
import com.fede.app.crypto.trading.logger.LogService;
import com.fede.app.crypto.trading.model._public.AssetPair;
import com.fede.app.crypto.trading.util.Utils;
import org.apache.commons.lang3.StringUtils;
import org.apache.commons.lang3.tuple.Pair;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.*;

import static com.fede.app.crypto.trading.model._public.AssetPair.FeeSchedule;

/**
 * Created by f.barbano on 08/10/2017.
 */
public class AssetPairsDBDao extends AbstractDBDao implements IAssetPairsDao {

	private static final ISimpleLog logger = LogService.getLogger(AssetPairsDBDao.class);

	private static final String FEE_TYPE_FEES = "fees";
	private static final String FEE_TYPE_FEES_MAKER = "fees_maker";
	private static final String LEVERAGE_TYPE_BUY = "buy";
	private static final String LEVERAGE_TYPE_SELL = "sell";

	private static final String Q_GET_VALIDS = "SELECT * FROM ASSET_PAIRS WHERE EXPIRE_TIME = 0";
	private static final String Q_GET_VALIDS_FEE = "SELECT * FROM ASSET_PAIRS_FEE WHERE PAIR_ID IN (@PAIR_ID_LIST@)";
	private static final String Q_GET_VALIDS_LEVERAGE = "SELECT * FROM ASSET_PAIRS_LEVERAGE WHERE PAIR_ID IN (@PAIR_ID_LIST@)";
	private static final String Q_UPDATE_EXPIRE_TIME = "UPDATE ASSET_PAIRS SET EXPIRE_TIME = ? WHERE EXPIRE_TIME = 0";
	private static final String Q_INSERT_NEW = "INSERT INTO ASSET_PAIRS (PAIR_NAME, ALT_NAME, A_CLASS_BASE, BASE, A_CLASS_QUOTE, QUOTE, LOT, PAIR_DECIMALS, LOT_DECIMALS, LOT_MULTIPLIER, FEE_VOLUME_CURRENCY, MARGIN_CALL, MARGIN_STOP, START_TIME, EXPIRE_TIME) VALUES @PAIRS_VALUES@";
	private static final String Q_INSERT_FEE = "INSERT INTO ASSET_PAIRS_FEE (PAIR_ID, FEE_TYPE, VOLUME, PERCENT_FEE) VALUES @FEE_VALUES@";
	private static final String Q_INSERT_LEVERAGE = "INSERT INTO ASSET_PAIRS_LEVERAGE (PAIR_ID, LEVERAGE_TYPE, LEVERAGE_VALUE) VALUES @LEVERAGE_VALUES@";

	private static final String PH_PAIR_ID_LIST = "@PAIR_ID_LIST@";
	private static final String PH_PAIRS_VALUES = "@PAIRS_VALUES@";
	private static final String PH_FEE_VALUES = "@FEE_VALUES@";
	private static final String PH_LEVERAGE_VALUES = "@LEVERAGE_VALUES@";




	public AssetPairsDBDao(Connection connection) {
		super(connection);
	}

	@Override
	public List<AssetPair> getAssetPairs() {
		Map<Long, AssetPair> map = inquiryTableAssetPairs();
		if(!map.isEmpty()) {
			inquiryTableAssetPairsFee(map);
			inquiryTableAssetPairsLeverage(map);
		}
		return new ArrayList<>(map.values());
	}

	@Override
	public void persistNewAssetPairs(Long callTime, List<AssetPair> newAssetPairs) {
		List<AssetPair> actuals = getAssetPairs();
		if(!actuals.equals(newAssetPairs)) {
			logger.info("New asset pairs downloaded!");

			updateExpireTime(callTime);

			int numInsert = insertInDB(Q_INSERT_NEW, PH_PAIRS_VALUES, Utils.join(newAssetPairs, ",", ap -> assetPairToValues(callTime, ap)));
			logger.info("%d new asset pairs inserted in DB", numInsert);

			// Get just inserted records to retrieve pairIDs (autogenerated by DB)
			Map<Long, AssetPair> apMap = inquiryTableAssetPairs();

			insertFeesAndLeverage(apMap, newAssetPairs);

		} else {
			logger.info("Assets downloaded are equals to the assets saved in DB: insert query not performed.");
		}
	}


	private Map<Long, AssetPair> inquiryTableAssetPairs() {
		try (PreparedStatement ps = connection.prepareStatement(Q_GET_VALIDS);
			 ResultSet rs = ps.executeQuery()){

			Map<Long, AssetPair> assetPairs = new HashMap<>();

			if(rs != null) {
				while(rs.next()) {
					Long pairID = rs.getLong("PAIR_ID");
					AssetPair ap = new AssetPair();
					ap.setPairName(rs.getString("PAIR_NAME"));
					ap.setAltName(rs.getString("ALT_NAME"));
					ap.setAClassBase(rs.getString("A_CLASS_BASE"));
					ap.setBase(rs.getString("BASE"));
					ap.setAClassQuote(rs.getString("A_CLASS_QUOTE"));
					ap.setQuote(rs.getString("QUOTE"));
					ap.setLot(rs.getString("LOT"));
					ap.setPairDecimals(rs.getInt("PAIR_DECIMALS"));
					ap.setLotDecimals(rs.getInt("LOT_DECIMALS"));
					ap.setLotMultiplier(rs.getInt("LOT_MULTIPLIER"));
					ap.setFeeVolumeCurrency(rs.getString("FEE_VOLUME_CURRENCY"));
					ap.setMarginCall(rs.getInt("MARGIN_CALL"));
					ap.setMarginStop(rs.getInt("MARGIN_STOP"));
					assetPairs.put(pairID, ap);
				}
			}
			return assetPairs;

		} catch (SQLException e) {
			logger.error(e);
			throw new TechnicalException(e);
		}
	}
	private void inquiryTableAssetPairsFee(Map<Long, AssetPair> assetPairs) {
		String pairIDsString = Utils.join(assetPairs.keySet(), ",", String::valueOf);
		String query = Q_GET_VALIDS_FEE.replace(PH_PAIR_ID_LIST, pairIDsString);

		try (PreparedStatement ps = connection.prepareStatement(query);
			 ResultSet rs = ps.executeQuery()){

			if(rs != null) {
				while(rs.next()) {
					long pairID = rs.getLong("PAIR_ID");
					int volume = rs.getInt("VOLUME");
					double percentFee = rs.getDouble("PERCENT_FEE");
					FeeSchedule fs = new FeeSchedule(volume, percentFee);

					String feeType = rs.getString("FEE_TYPE");
					if(FEE_TYPE_FEES.equals(feeType)) {
						assetPairs.get(pairID).getFees().add(fs);
					} else {
						assetPairs.get(pairID).getFeesMaker().add(fs);
					}
				}
			}

		} catch (SQLException e) {
			logger.error(e);
			throw new TechnicalException(e);
		}
	}
	private void inquiryTableAssetPairsLeverage(Map<Long, AssetPair> assetPairs) {
		String pairIDsString = Utils.join(assetPairs.keySet(), ",", String::valueOf);
		String query = Q_GET_VALIDS_LEVERAGE.replace(PH_PAIR_ID_LIST, pairIDsString);

		try (PreparedStatement ps = connection.prepareStatement(query);
			 ResultSet rs = ps.executeQuery()){

			if(rs != null) {
				while(rs.next()) {
					long pairID = rs.getLong("PAIR_ID");
					int volume = rs.getInt("LEVERAGE_VALUE");
					String leverageType = rs.getString("LEVERAGE_TYPE");
					if(LEVERAGE_TYPE_BUY.equals(leverageType)) {
						assetPairs.get(pairID).getLeverageBuy().add(volume);
					} else {
						assetPairs.get(pairID).getLeverageSell().add(volume);
					}
				}
			}

		} catch (SQLException e) {
			logger.error(e);
			throw new TechnicalException(e);
		}
	}

	private void updateExpireTime(Long callTime) {
		try (PreparedStatement ps = connection.prepareStatement(Q_UPDATE_EXPIRE_TIME)) {
			ps.setLong(1, callTime);
			int numUpdated = ps.executeUpdate();
			if (numUpdated > 0) {
				logger.info("%d asset pairs updated: expire time changed from 0 to %d", numUpdated, callTime);
			}
		} catch (SQLException ex) {
			logger.error(ex);
			throw new TechnicalException(ex);
		}
	}
	private int insertInDB(String query, String placeholder, String values) {
		try (PreparedStatement ps = connection.prepareStatement(query.replace(placeholder, values))) {
			return ps.executeUpdate();
		} catch (SQLException ex) {
			logger.error(ex);
			throw new TechnicalException(ex);
		}
	}
	private void insertFeesAndLeverage(Map<Long, AssetPair> apMap, List<AssetPair> newAssetPairs) {
		StringBuilder sbFee = new StringBuilder();
		StringBuilder sbLeverage = new StringBuilder();

		Map<String, AssetPair> pairMap = Utils.toMapSingle(newAssetPairs, AssetPair::getPairName);

		for (Map.Entry<Long, AssetPair> entry : apMap.entrySet()) {
			AssetPair ap = pairMap.get(entry.getValue().getPairName());

			String fees = feesToValues(entry.getKey(), ap);
			if(StringUtils.isNotBlank(fees)) {
				if (sbFee.length() > 0) 		sbFee.append(",");
				sbFee.append(fees);
			}

			String leverages = leverageToValues(entry.getKey(), ap);
			if(StringUtils.isNotBlank(leverages)) {
				if (sbLeverage.length() > 0) 	sbLeverage.append(",");
				sbLeverage.append(leverages);
			}
		}

		if(sbFee.length() > 0) {
			int numInsert = insertInDB(Q_INSERT_FEE, PH_FEE_VALUES, sbFee.toString());
			logger.info("%d asset pairs fees inserted in DB", numInsert);
		}

		if(sbLeverage.length() > 0) {
			int numInsert = insertInDB(Q_INSERT_LEVERAGE, PH_LEVERAGE_VALUES, sbLeverage.toString());
			logger.info("%d asset pairs leverages inserted in DB", numInsert);
		}
	}
	private String assetPairToValues(Long callTime, AssetPair assetPair) {
		//PAIR_NAME, ALT_NAME, A_CLASS_BASE, BASE, A_CLASS_QUOTE, QUOTE, LOT, PAIR_DECIMALS, LOT_DECIMALS, LOT_MULTIPLIER, FEE_VOLUME_CURRENCY, MARGIN_CALL, MARGIN_STOP
		return String.format("('%s', '%s', '%s', '%s', '%s', '%s', '%s', %d, %d, %d, '%s', %d, %d, %d, 0)",
			assetPair.getPairName(),
			assetPair.getAltName(),
			assetPair.getAClassBase(),
			assetPair.getBase(),
			assetPair.getAClassQuote(),
			assetPair.getQuote(),
			assetPair.getLot(),
			assetPair.getPairDecimals(),
			assetPair.getLotDecimals(),
			assetPair.getLotMultiplier(),
			assetPair.getFeeVolumeCurrency(),
			assetPair.getMarginCall(),
			assetPair.getMarginStop(),
			callTime
		);
	}
	private String feesToValues(Long pairID, AssetPair assetPair) {
		StringBuilder sb = new StringBuilder();
		for(FeeSchedule fee : assetPair.getFees()) {
			if(sb.length() > 0)		sb.append(",");
			String val = String.format("(%d, '%s', %d, %s)", pairID, FEE_TYPE_FEES, fee.getVolume(), Utils.toString(fee.getPercentFee()));
			sb.append(val);
		}
		for(FeeSchedule fee : assetPair.getFeesMaker()) {
			if(sb.length() > 0)		sb.append(",");
			String val = String.format("(%d, '%s', %d, %s)", pairID, FEE_TYPE_FEES_MAKER, fee.getVolume(), Utils.toString(fee.getPercentFee()));
			sb.append(val);
		}
		return sb.toString();
	}
	private String leverageToValues(Long pairID, AssetPair assetPair) {
		StringBuilder sb = new StringBuilder();
		for(Integer lev : assetPair.getLeverageBuy()) {
			if(sb.length() > 0)		sb.append(",");
			String val = String.format("(%d, '%s', %d)", pairID, LEVERAGE_TYPE_BUY, lev);
			sb.append(val);
		}
		for(Integer lev : assetPair.getLeverageSell()) {
			if(sb.length() > 0)		sb.append(",");
			String val = String.format("(%d, '%s', %d)", pairID, LEVERAGE_TYPE_SELL, lev);
			sb.append(val);
		}
		return sb.toString();
	}
}
